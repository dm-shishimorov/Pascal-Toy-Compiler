#include "lexems.hpp"

std::map<std::string, int> lexems = {
  { "begin",        TOKEN_TYPE_RESERVED_WORD },
  { "forward",      TOKEN_TYPE_RESERVED_WORD },
  { "do",           TOKEN_TYPE_RESERVED_WORD },
  { "else",         TOKEN_TYPE_RESERVED_WORD },
  { "end",          TOKEN_TYPE_RESERVED_WORD },
  { "for",          TOKEN_TYPE_RESERVED_WORD },
  { "function",     TOKEN_TYPE_RESERVED_WORD },
  { "if",           TOKEN_TYPE_RESERVED_WORD },
  { "array",        TOKEN_TYPE_RESERVED_WORD },
  { "of",           TOKEN_TYPE_RESERVED_WORD },
  { "procedure",    TOKEN_TYPE_RESERVED_WORD },
  { "program",      TOKEN_TYPE_RESERVED_WORD },
  { "record",       TOKEN_TYPE_RESERVED_WORD },
  { "then",         TOKEN_TYPE_RESERVED_WORD },
  { "to",           TOKEN_TYPE_RESERVED_WORD },
  { "type",         TOKEN_TYPE_RESERVED_WORD },
  { "var",          TOKEN_TYPE_RESERVED_WORD },
  { "while",        TOKEN_TYPE_RESERVED_WORD },
  { "break",        TOKEN_TYPE_RESERVED_WORD },
  { "continue",     TOKEN_TYPE_RESERVED_WORD },
  { "downto",       TOKEN_TYPE_RESERVED_WORD },
  { "exit",         TOKEN_TYPE_RESERVED_WORD },
  { "repeat",       TOKEN_TYPE_RESERVED_WORD },
  { "until",        TOKEN_TYPE_RESERVED_WORD },
  { "and",          TOKEN_TYPE_OPERATOR },
  { "div",          TOKEN_TYPE_OPERATOR },
  { "mod",          TOKEN_TYPE_OPERATOR },
  { "not",          TOKEN_TYPE_OPERATOR },
  { "or",           TOKEN_TYPE_OPERATOR },
  { "xor",          TOKEN_TYPE_OPERATOR }
};